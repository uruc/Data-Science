---
title: "Bad Passwords"
subtitle: "Ibrahim Uruc Tarim"
format:
  revealjs: 
    theme: dark
    width: 1600
    height: 900
    smaller: true
    scrollable: true
    slide-number: true
    chalkboard:
      buttons: true
    preview-links: auto
resources:
  - demo.pdf
editor: 
  markdown: 
    wrap: 72
---

```{r setup, include = FALSE}

knitr::opts_chunk$set(
  cache = FALSE, # if TRUE knitr will cache results to reuse in future knits
  fig.width = 6, # the width for plots created by code chunk
  fig.height = 4.5, # the height for plots created by code chunk
  fig.align = 'center', # how to align graphics. 'left', 'right', 'center'
  dpi = 300,
  dev = 'png',
  # results = 'asis', # knitr passes through results without reformatting
  echo = TRUE, # if FALSE knitr won't display code in chunk above it's results
  message = TRUE, # if FALSE knitr won't display messages generated by code
  strip.white = TRUE, # if FALSE knitr won't remove white spaces at beg or end
  warning = FALSE) # if FALSE knitr won't display warning messages in the doc

```

```{r, styleguide, include = FALSE}
first_custom <- function() {
  theme_minimal() +
    theme(
      axis.line = element_line(color = "gray0"),
      plot.background  = element_rect(fill = "grey95"),
      panel.grid.major = element_line(linewidth = 0.5, color = "gray80"),
      panel.grid.minor = element_blank(),
      #panel.grid.minor = element_line(color = "gray85"),
      plot.margin = margin(15, 15, 15 ,15),
      plot.title = element_text(face = "bold"),
      plot.title.position = "plot",
      plot.caption = element_text(size = 8, face = "italic"),
      plot.caption.position = "plot",
      legend.background = element_rect(),
      legend.justification = (c(1,0)),
      legend.text = element_text(size = 8),
      legend.title = element_text(size = 8),
      legend.key.size = unit(0.25, "cm")
    )
}

```

```{r, include = FALSE}
library(tidyverse)
library(ggplot2)
library(dplyr)
library(patchwork)
library(plotly)
library(viridis)
library(RColorBrewer)
library(hrbrthemes)
library(ggridges)
library(gt)
library(htmlwidgets)
```

## About the Dataset

**Useful Variables**

-   Password: The actual password string.
-   Category: This column categorizes passwords, based on their
    complexity or style (e.g., 'password-related', 'simple-alphanumeric'
    or relation).
-   Value and Time Unit: These two columns appear to relate to the
    strength or vulnerability of the password, possibly indicating how
    long it would take to crack the password. 'Value' gives a numerical
    figure, and 'time_unit' provides the unit of time (e.g., years,
    minutes, seconds).
-   Offline Crack Sec: This might indicate the time in seconds it would
    take to crack the password using offline methods.
-   Strength: A numerical representation of the password's strength.

## Unveiling Password Vulnerabilities

::: columns
::: {.column width="40%"}
<font size="5"> <b>Predictable Patterns: Common Password Categories</b>

-   Top Trends: Names and simple patterns lead as the most common
    choices.
-   Preference for Easy: Users tend to prefer memorable over complex
    passwords.
-   Vulnerability by Category: Popularity in these categories often
    equates to higher risk.

<br><br><br><br><br><br><br><br> <b>Shortcuts to Breach: Password Length
Analysis</b>

-   Length Matters: Majority of passwords fall within a risky, short
    length.
-   Six Characters: The most common password length, yet easily
    crackable.
-   Strength in Numbers: Longer passwords are less frequent but more
    secure.

</font>
:::

::: {.column width="60%"}
<iframe src="p_interactive.html" style="width:100%; height:450px">

</iframe>

![](plot1.png)
:::
:::

## Dissecting Password Strength by Category

::: columns
::: {.column width="50%"}
![](plot3.png) <font size="4.5"> **Median Strength Across Categories**

-   Diverse Profiles: Median strength varies, indicating different risk
    levels.
-   Alphanumeric Edge: Categories with alphanumeric combinations show
    resilience.
-   Weak Spots: Common words and patterns are the weakest links.

</font>
:::

::: {.column width="50%"}
![](plot2.png) <font size="4.5"> **Spread of Password Strength**

-   Outliers Exposed: Some passwords show unexpected strength within
    their categories.
-   Consistency in Weakness: Several categories consistently score low
    on strength.
-   A Case for Complexity: Mix of both weak and strong password habits.

</font>
:::
:::

## Strength by Type and Crack Times

::: columns
::: {.column width="50%"}
![](plot5.png) <font size="4.5"> **Strength Variations**

-   Type Matters: Alphanumeric passwords are stronger than numeric or
    letter-only types.
-   Variability: Alphanumeric passwords vary widely in strength,
    suggesting diverse complexity.
-   Weakness in Simplicity: Single-type passwords are predictably weaker
    and more vulnerable.

</font>
:::

::: {.column width="50%"}
![](plot4.png) <font size="4.5"> **Cracking Timeframes**

-   Online vs. Offline: Crack times vary greatly between online and
    offline attacks.
-   Nearly all weak passwords can be cracked within seconds.
-   Why does "password" take longer to crack compared to ncc1701?

</font>
:::
:::

## Online vs Offline Password Cracking

::: columns
::: {.column width="50%"}
<font size="5"> **Online Attacks**

-   Involves guessing login credentials via interfaces for legitimate
    users (e.g., web pages, SSH servers).
-   Methods: Dictionary and Brute Force attacks.
-   Slower and noisier, easily detectable via logs.
-   Can be mitigated by limiting login attempts and account lockouts.
    </font>
:::

::: {.column width="50%"}
<font size="5"> **Offline Attacks**

-   Cracks passwords from storage files (e.g., SAM or /etc/shadow) after
    gaining system access.
-   Methods: Brute Force, Mask, Dictionary, Rule-Based, and Hybrid
    attacks.
-   Much faster than online cracking; leaves no trace on the target
    system.
-   Mitigated by using strong hashing algorithms with salting and
    iterations. </font>
:::
:::

## Which is More Important? Type or Length?

::: columns
::: {.column width="40%"}
<br> <font size="5"> **Analyzing Crack Time by Password
Characteristics**

-   Length vs. Complexity: Longer passwords aren't always stronger;
    complexity also plays a key role.
-   Alphanumeric Robustness: Passwords that mix letters and numbers tend
    to require more time to crack.
-   Simple Patterns at Risk: Passwords with simple numeric or alphabetic
    patterns are cracked much faster, regardless of length.

**#thinkrandom**

-   Length Advantage
-   Effective Communication
-   Breaking Stereotypes
-   Enhanced Usability

</font>
:::

::: {.column width="60%"}
![](plot6.png)
:::
:::

## Or Does Your Password Matter At All?

::: columns
::: {.column width="30%"}
<font size="5">

-   Credential Stuffing: High frequency, low difficulty attacks that
    rely on user password reuse.
-   Phishing: Targets user behavior, not password strength.
-   Keystroke Logging: Low frequency but can capture any password
    regardless of its complexity.
-   Local Discovery & Extortion: Relatively rare, these attacks bypass
    password strength through social engineering or physical access.
-   Password Spray & Brute Force: Only effective on common or simple
    passwords; strong, unique passwords are more resistant.

</font>
:::

::: {.column width="70%"}
<iframe src="gt_table.html" style="width:100%; height:660px">

</iframe>

<font size="3">
<i>https://techcommunity.microsoft.com/t5/microsoft-entra-blog/your-pa-word-doesn-t-matter/ba-p/731984</i>
</font>
:::
:::

## Database Extraction and Cracking, The Scary One

-   Database Extraction Threat: Unauthorized retrieval of databases
    containing sensitive user credentials.
-   Hashing: Converts passwords into secure, non-reversible hashes using
    algorithms like SHA256.
-   Salting: Adds unique data to each password before hashing to prevent
    identical hashes for the same passwords.
-   Attack Complexity: More challenging in robust systems like cloud
    environments due to additional security layers. Easier in
    on-premises systems if attackers gain high-level access.

<br><br>

\*\*Database full of hashes stolen - how do they proceed?

-   Get a cracking rig.
-   Do the homework to figure out the algorithm
-   Build an initial list of passwords to try.(Billions of passwords
    disclosed)
-   Try every password on that list against the target account.
-   Run every allowable password going as far as the rig and time will
    allow.

## Password Cracking Times in 2023

<img src="2023_Password_Table_Square_1.png" width="700" height="700"/>
<img src="2023_Password_Table_Chat_GPT_1.png" width="700" height="700"/>

::: {style="display: flex; justify-content: center;"}
<img src="2023_Password_Table.gif"/>
:::

## Conclusion

::: columns
::: {.column width="60%"}
-   Password Effectiveness in Breaches: In breaches, password length and
    uniqueness are crucial. Passwords over 12 characters, ideally
    generated by password managers, offer better security.
-   Password Manager Benefits: Generates long, random strings, enhancing
    security. Issues include usability and being a high-value target,
    but they significantly mitigate risks in database breaches.
-   MFA as a Crucial Security Layer: Significantly more effective than
    just password protection. Accounts with MFA are over 99.9% less
    likely to be compromised. <br><br><br>

<font size="6"> **Key Takeaway: While strong, unique passwords are
important, enabling Multi-Factor Authentication (MFA) is a critical step
in safeguarding your accounts.** </font>
:::
:::

```{r, include = FALSE}

passwords <- readr::read_csv('https://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2020/2020-01-14/passwords.csv')

passwords <- na.omit(passwords)
passwords <- passwords %>% select(-font_size)

online_crack_sec <- function(value, unit) {
  if (unit == "years") {
    return(value * 365 * 24 * 60 * 60)  
  } else if (unit == "months") {
    return(value * 30 * 24 * 60 * 60)   
  } else if (unit == "weeks") {
    return(value * 7 * 24 * 60 * 60)    
  } else if (unit == "days") {
    return(value * 24 * 60 * 60)        
  } else if (unit == "hours") {
    return(value * 60 * 60)             
  } else if (unit == "minutes") {
    return(value * 60)                  
  } else if (unit == "seconds") {
    return(value)                       
  } else {
    return(NA)                          
  }
}


passwords <- passwords %>%
  mutate(online_crack_sec = mapply(online_crack_sec, value, time_unit))

category_count <- passwords %>%
  count(category) %>%
  arrange(desc(n))

top_passwords_by_category <- passwords %>%
  arrange(category, rank) %>%
  group_by(category) %>%
  slice_head(n = 3) %>%
  summarise(top_passwords = paste(password, collapse = ", ")) %>%
  ungroup()


category_count <- passwords %>%
  count(category) %>%
  left_join(top_passwords_by_category, by = "category")


p <- ggplot(category_count, aes(x = n, y = reorder(category, n), text = top_passwords)) +
  geom_bar(stat = "identity", fill = "#fde725") +
  labs(title = "Most Common Password Categories", x = "Frequency", y = "Category") +
  theme_modern_rc() +
  theme(
    legend.position="none",
    plot.title = element_text(size=13),
    axis.text.y = element_text(size = 8), 
    axis.text.x = element_text(size = 8),
    axis.title = element_text(colour = "white"))


p_interactive <- ggplotly(p, tooltip = "text") %>% 
  layout(
    yaxis = list(
      title = list(
        standoff = 10,
        font = list(size = 20)
      ),
      tickfont = list(size = 18)  
    ),
    xaxis = list(
      title = list(
        font = list(size = 20)
      ),
      tickfont = list(size = 18)  
    ),
    title = list(
      font = list(size = 24)
    )
  )

p_interactive

passwords$length <- nchar(passwords$password)


plot1 <- ggplot(passwords, aes(x = length)) +
  geom_histogram(binwidth = 0.5, fill = "#fde725") + 
  labs(title = "Password Length Distribution",
       x = "Length of Password",  
       y = "Frequency") +
  scale_x_continuous(breaks = 4:9, 
                     labels = 4:9) + 
  theme_modern_rc() +
  theme(
    legend.position="none",
    plot.title = element_text(size=13),
    axis.text.y = element_text(size = 8), 
    axis.text.x = element_text(size = 8),
    axis.title = element_text(colour = "white"),
    axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 15)),
    axis.title.y = element_text(face = "bold", size = 11, margin = margin(r = 15)))
  

plot1



plot2 <- ggplot(passwords, aes(x = category, y = strength, fill = category)) +
  geom_boxplot(color = "white", size = 0.1, outlier.size = 0.7) +
  geom_jitter(size = 0.3, alpha = 0.4, color = "white") + 
  coord_flip() +
  scale_fill_viridis(discrete = TRUE) +
  labs(title = "Password Category Strength", x = "Category", y = "Strength") +
  theme_modern_rc() +
  theme(
    legend.position="none",
    plot.title = element_text(size=13), 
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    axis.title = element_text(colour = "white"),
    axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 15)),
    axis.title.y = element_text(face = "bold", size = 11, margin = margin(r = 15)))

plot2




plot3 <- ggplot(data = passwords, mapping = aes(x = strength, y = category, fill = category)) + 
        geom_density_ridges(scale = 1.5, alpha = 0.8, quantile_lines = TRUE, quantiles = 2) + 
        labs(x = "Strength", y = "Category", title = "Password Category Median Strength") + 
        scale_y_discrete(expand = c(0.05, 0)) + 
        theme_ridges(grid = FALSE, center = TRUE) + 
        xlim(0,15) + 
        scale_fill_viridis(discrete = TRUE) +
  theme_modern_rc() +
  theme(
    legend.position="none",
    plot.title = element_text(size=13), 
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    axis.title = element_text(colour = "white"),
    axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 15)),
    axis.title.y = element_text(face = "bold", size = 11, margin = margin(r = 15)))

plot3

selected_passwords <- passwords %>% 
  filter(password %in% c('trustno1', 'password', 'ncc1701'))

plot_data <- selected_passwords %>%
  select(password, offline_crack_sec, online_crack_sec) %>%
  pivot_longer(cols = c(offline_crack_sec, online_crack_sec), 
               names_to = "crack_type", values_to = "time_sec")

breaks <- c(1, 60*60*24*7, 60*60*24*30, 60*60*24*365)
labels <- c("1 Second", "Weeks", "Months", "Years")

plot4 <- ggplot(plot_data, aes(x=password, y=time_sec, fill=crack_type)) + 
  geom_col(binwidth = 0.5, position="dodge") +
  scale_y_log10(breaks = c(1e-5, breaks), labels = c("0.00001 s", labels)) +
  scale_fill_viridis(discrete = TRUE,
                     name = "Crack Method",
    labels = c("Offline", "Online")) + 
  labs(title="Crack Times for Select Passwords",  
       y = "Crack Time") +
  theme_modern_rc() +
  theme(
    legend.position="bottom",
    legend.title = element_text(size = 8, face = "bold"),
    plot.title = element_text(size=13), 
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    axis.title = element_text(colour = "white"),
    axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 15)),
    axis.title.y = element_text(face = "bold", size = 11, margin = margin(r = 15)))

plot4


passwords <- passwords %>%
  mutate(password_type = case_when(
    str_detect(password, "^[A-Za-z]+$") ~ "Only Letters",
    str_detect(password, "^[0-9]+$") ~ "Only Numbers",
    str_detect(password, "^[A-Za-z0-9]+$") ~ "Alphanumeric",
    TRUE ~ "Other"
  ))

plot5 <- ggplot(passwords, aes(x = password_type, y = strength, fill = password_type)) +
  geom_violin(trim = FALSE) +
  geom_jitter(width = 0.1, size = 0.5, alpha = 0.5, color = "red") +
  scale_fill_viridis(discrete = TRUE, option = "D") +
  labs(title = "Password Strength by Type", x = "Password Type", y = "Strength") +
  theme_modern_rc() +
  theme(
    legend.position="none",
    plot.title = element_text(size=13), 
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    axis.title = element_text(colour = "white"),
    axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 15)),
    axis.title.y = element_text(face = "bold", size = 11, margin = margin(r = 15)))


plot5

set.seed(123)
randomp <- passwords %>%
  group_by(length, password_type) %>%
  summarize(mean_crack_time = mean(offline_crack_sec, na.rm = TRUE), .groups = 'keep') %>%
  sample_n(size = 1) %>%
  ungroup()


randomp <- randomp %>%
  left_join(passwords, by = c("length", "password_type")) %>%
  group_by(length, password_type) %>%
  mutate(example_password = sample(password, 1)) %>%
  slice(1) %>%
  ungroup()


plot6 <- ggplot(randomp, aes(x = length, y = mean_crack_time, color = password_type, label = example_password)) +
  geom_point(size = 3) +
  geom_text(aes(label = example_password), nudge_x = 0.3, nudge_y = 0.3, check_overlap = TRUE, size = 2) +
  scale_y_continuous(trans = 'log10', labels = scales::comma) +
  scale_color_manual(values = c("Alphanumeric" = "#32648e", "Only Letters" = "#35b779", "Only Numbers" = "#fde725")) +
  labs(title = "Average Crack Time by Type and Length",
       x = "Password Length", y = "Average Crack Time (sec)", color = "Password Type") +
  theme_modern_rc() +
  theme(
    legend.position = "bottom",
    legend.title = element_text(size = 8, face = "bold"),
    legend.text = element_text(size = 8),       
    legend.key.size = unit(0.5, 'lines'),
    plot.title = element_text(size = 13),
    axis.text.y = element_text(size = 8),
    axis.text.x = element_text(size = 8),
    axis.title.x = element_text(face = "bold", size = 11, margin = margin(t = 15)),
    axis.title.y = element_text(face = "bold", size = 11, margin = margin(r = 15))
  )

plot6

attacks <- read_csv("attack.csv")

num_rows <- nrow(attacks)

gt_table <- attacks %>%
  gt() %>%
  tab_header(
    title = md("Password Attack Vectors"),
    subtitle = md("Evaluating the Effectiveness of Passwords Against Common Attacks")
  ) %>%
  tab_options(
    heading.background.color = "gray10",
    table.background.color = "gray10"
  ) %>%
  tab_style(
    style = list(
      cell_text(color = "white"),
      cell_fill(color = "gray10")
    ),
    locations = cells_body()
  ) %>%
  tab_style(
    style = cell_text(color = "white", weight = "bold"),
    locations = cells_column_labels()
  ) 


gt_table <- gt_table %>%
  tab_style(
    style = cell_borders(
      sides = c("top", "bottom"), 
      color = "red", 
      weight = px(2)
    ),
    locations = cells_body(
      rows = (num_rows-1):num_rows
    )
  )

# Print the modified table
print(gt_table)

gtsave(gt_table, filename = "gt_table.html")


width <- 6
height <- 4.5

ggsave("plot1.png", plot = plot1, width = width, height = height)
ggsave("plot2.png", plot = plot2, width = width, height = height)
ggsave("plot3.png", plot = plot3, width = width, height = height)
ggsave("plot4.png", plot = plot4, width = width, height = height)
ggsave("plot5.png", plot = plot5, width = width, height = height)
ggsave("plot6.png", plot = plot6, width = width, height = height)
saveWidget(p_interactive, file = "C:/Users/iuruc/OneDrive/Desktop/uruc-23f-dsci354-454-ixt87-04b9bcffffa2/uruc-23f-dsci354-454-ixt87-04b9bcffffa2/7-Final Exam/p_interactive.html")



```
